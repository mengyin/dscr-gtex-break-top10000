#   sebetahat=sqrt(rgamma(N,shape=n/2,rate=n/(2*truevar)))
#   betahat=rnorm(N,mean=truemean,sd=truese)
return(list(truemean=truemean,truese=truese,betahat=betahat,sebetahat=sebetahat,
Y=Y,ind=ind,n=n,lnsd=lnsd,c=c,pi=pi,null=null))
}
# function to plot the Empirical Bayes prior of variances/precisions
# xmax: plot density on (0,xmax)
logNprior=function(lnsd,c,pi,unimodal,xmax){
xgrid=seq(0.0001,xmax,by=0.01)
if(unimodal=='variance'){
EBprior.var.sep=dlnorm(outer(xgrid,rep(1,length(lnsd))),
mean=outer(rep(1,length(xgrid)),log(c)+lnsd^2),
sd=outer(rep(1,length(xgrid)),lnsd))
EBprior.var=rowSums(outer(rep(1,length(xgrid)),pi)*EBprior.var.sep)
EBprior.prec.sep=dlnorm(outer(xgrid,rep(1,length(lnsd))),
mean=outer(rep(1,length(xgrid)),-(log(c)+lnsd^2)),
sd=outer(rep(1,length(xgrid)),lnsd))
EBprior.prec=rowSums(outer(rep(1,length(xgrid)),pi)*EBprior.prec.sep)
}else if (unimodal=='precision'){
EBprior.var.sep=dlnorm(outer(xgrid,rep(1,length(lnsd))),
mean=outer(rep(1,length(xgrid)),-(log(c)+lnsd^2)),
sd=outer(rep(1,length(xgrid)),lnsd))
EBprior.var=rowSums(outer(rep(1,length(xgrid)),pi)*EBprior.var.sep)
EBprior.prec.sep=dlnorm(outer(xgrid,rep(1,length(lnsd))),
mean=outer(rep(1,length(xgrid)),log(c)+lnsd^2),
sd=outer(rep(1,length(xgrid)),lnsd))
EBprior.prec=rowSums(outer(rep(1,length(xgrid)),pi)*EBprior.prec.sep)
}
return(list(xgrid=xgrid,EBprior.var=EBprior.var,EBprior.prec=EBprior.prec,
EBpriorvar.sep=EBprior.var.sep, EBprior.prec.sep=EBprior.prec.sep))
}
allsimrob=function(nsim,N,Nnull,altmean,altsd,df,pi,lnsd,c,unimodal='variance'){
LNprior=logNprior(lnsd,c,pi,unimodal,xmax=10*c)
mse.raw=rep(NA,nsim)
mse.vash=rep(NA,nsim)
mse.vash.s=rep(NA,nsim)
mse.limma=rep(NA,nsim)
mse.limma.s=rep(NA,nsim)
qval.vash=matrix(rep(NA,nsim*N),nrow=nsim)
qval.vash.s=matrix(rep(NA,nsim*N),nrow=nsim)
qval.limma=matrix(rep(NA,nsim*N),nrow=nsim)
qval.limma.s=matrix(rep(NA,nsim*N),nrow=nsim)
fdr.vash=matrix(rep(NA,nsim*N),nrow=nsim)
fdr.vash.s=matrix(rep(NA,nsim*N),nrow=nsim)
fdr.limma=matrix(rep(NA,nsim*N),nrow=nsim)
fdr.limma.s=matrix(rep(NA,nsim*N),nrow=nsim)
fdr.raw=matrix(rep(NA,nsim*N),nrow=nsim)
for (i in 1:nsim){
d = simrob(N,Nnull,altmean,altsd,df,pi,lnsd,c,unimodal='variance')
vash.s=vash(d$sebetahat,df=df,d$betahat,singlecomp=TRUE)
vash=vash(d$sebetahat,df=df,d$betahat,singlecomp=FALSE)
fit.s <- lmFit(d$Y, rep(1,dim(d$Y)[2]))
fit.s <- eBayes(fit.s)
fit = eBayes(fit.s,robust=TRUE)
pvalue.raw=2*pt(d$betahat/d$sebetahat,df=df,lower.tail=TRUE)
mse.raw[i]=mean((d$truese^2-d$sebetahat^2)^2)
mse.vash[i]=mean((d$truese^2-vash$PosteriorMean^2)^2)
mse.vash.s[i]=mean((d$truese^2-vash.s$PosteriorMean^2)^2)
mse.limma[i]=mean((d$truese^2-fit$s2.post*fit$stdev.unscaled^2)^2)
mse.limma.s[i]=mean((d$truese^2-fit.s$s2.post*fit.s$stdev.unscaled^2)^2)
qval.vash[i,]=qvalue(vash$pvalue)$qval
qval.vash.s[i,]=qvalue(vash.s$pvalue)$qval
qval.limma[i,]=qvalue(fit$p.value)$qval
qval.limma.s[i,]=qvalue(fit.s$p.value)$qval
o.raw = order(pvalue.raw)
o.vash = order(qval.vash[i,])
o.vashs = order(qval.vash.s[i,])
o.limma = order(qval.limma[i,])
o.limmas = order(qval.limma.s[i,])
qval.vash[i,]=sort(qval.vash[i,])
qval.vash.s[i,]=sort(qval.vash.s[i,])
qval.limma[i,]=sort(qval.limma[i,])
qval.limma.s[i,]=sort(qval.limma.s[i,])
fdr.raw[i,]=(cumsum(d$null[o.raw])/(1:N))
fdr.vash[i,]=(cumsum(d$null[o.vash])/(1:N))
fdr.vash.s[i,]=(cumsum(d$null[o.vashs])/(1:N))
fdr.limma[i,]=(cumsum(d$null[o.limma])/(1:N))
fdr.limma.s[i,]=(cumsum(d$null[o.limmas])/(1:N))
}
group=rep(c("vash","limma","limma.robust","baseline"),each=nsim)
mse=c(mse.vash,mse.limma.s,mse.limma,mse.raw)
allmse=data.frame(mse,group)
return(list(allmse=allmse,
qval.vash=qval.vash,
qval.vash.s=qval.vash.s,
qval.limma=qval.limma,
qval.limma.s=qval.limma.s,
fdr.vash=fdr.vash,
fdr.vash.s=fdr.vash.s,
fdr.limma=fdr.limma,
fdr.limma.s=fdr.limma.s,
fdr.raw=fdr.raw,
LNprior=LNprior))
}
set.seed(88)
ptm <- proc.time()
test.1=allsim(nsim=50,N=10000,Nnull=9000,altmean=0,altsd=2,df=3,pi=1,alpha=5,c=1)
plot(test.1$Gprior$xgrid,test.1$Gprior$EBprior.var,type='l')
proc.time() - ptm
# Boxplots of MSE
boxplot(mse~group,data=test.1$allmse,ylim=c(0,0.7))
# True FDR
ng=100
plot(apply(test.1$fdr.vash,2,mean)[1:ng],type='l',ylim=c(0,0.2))
lines(apply(test.1$fdr.vash.s,2,mean)[1:ng],col='red')
lines(apply(test.1$fdr.limma,2,mean)[1:ng],col='blue')
lines(apply(test.1$fdr.limma.s,2,mean)[1:ng],col='green')
legend('topleft',col=c('black','red','blue','green'),lty=rep(1,4),
legend=c('vash','vash.s','limma.rob','limma'))
title('True FDR')
# # Estimated q-values
# plot(apply(test.1$qval.vash,2,mean)[1:ng],type='l',ylim=c(0,0.2))
# lines(apply(test.1$qval.vash.s,2,mean)[1:ng],col='red')
# lines(apply(test.1$qval.limma,2,mean)[1:ng],col='blue')
# lines(apply(test.1$qval.limma.s,2,mean)[1:ng],col='green')
# title('Estimated FDR')
##########
ptm <- proc.time()
test.2=allsim(nsim=50,N=10000,Nnull=9000,altmean=0,altsd=2,df=3,pi=c(0.1,0.9),alpha=c(2,10),c=1)
plot(test.2$Gprior$xgrid,test.2$Gprior$EBprior.var,type='l')
proc.time() - ptm
# Boxplots of MSE
boxplot(mse~group,data=test.2$allmse,ylim=c(0,1.5))
# True FDR
ng=100
plot(apply(test.2$fdr.vash,2,mean)[1:ng],type='l',ylim=c(0,0.2))
#lines(apply(test.2$fdr.vash.s,2,mean)[1:ng],col='red')
lines(apply(test.2$fdr.limma,2,mean)[1:ng],col='blue')
lines(apply(test.2$fdr.limma.s,2,mean)[1:ng],col='green')
legend('topleft',col=c('black','red','blue','green'),lty=rep(1,4),
legend=c('vash','vash.s','limma.rob','limma'))
title('True FDR')
##########
ptm <- proc.time()
test.3=allsim(nsim=10,N=10000,Nnull=9000,altmean=0,altsd=2,df=3,pi=c(0.1,0.4,0.5),alpha=c(1,2,30),c=1)
plot(test.3$Gprior$xgrid,test.3$Gprior$EBprior.var,type='l')
proc.time() - ptm
# Boxplots of MSE
boxplot(mse~group,data=test.3$allmse,ylim=c(0,1.5))
# True FDR
ng=100
plot(apply(test.3$fdr.vash,2,mean)[1:ng],type='l',ylim=c(0,0.2))
lines(apply(test.3$fdr.limma,2,mean)[1:ng],col='blue')
lines(apply(test.3$fdr.limma.s,2,mean)[1:ng],col='green')
legend('topleft',col=c('black','red','blue','green'),lty=rep(1,4),
legend=c('vash','vash.s','limma.rob','limma'))
title('True FDR')
#######
test.4=allsim(nsim=50,N=10000,Nnull=9000,altmean=0,altsd=2,df=10,pi=1,alpha=5,c=1)
test.5=allsim(nsim=50,N=10000,Nnull=9000,altmean=0,altsd=2,df=10,pi=c(0.1,0.9),alpha=c(2,10),c=1)
test.6=allsim(nsim=10,N=10000,Nnull=9000,altmean=0,altsd=2,df=10,pi=c(0.1,0.4,0.5),alpha=c(1,2,30),c=1)
test.7=allsim(nsim=50,N=10000,Nnull=9000,altmean=0,altsd=2,df=50,pi=1,alpha=5,c=1)
test.8=allsim(nsim=50,N=10000,Nnull=9000,altmean=0,altsd=2,df=50,pi=c(0.1,0.9),alpha=c(2,10),c=1)
test.9=allsim(nsim=50,N=10000,Nnull=9000,altmean=0,altsd=2,df=50,pi=c(0.1,0.4,0.5),alpha=c(1,2,30),c=1)
save.image("/Volumes/PERSONAL/MS/myvash/Simulations/compare.RData")
library("knitr", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
ex02.100colyear <- read.delim("/Volumes/PERSONAL/UChicago/15Winter/220/Mac-Text/Chapter 2/ex02-100colyear.txt")
View(ex02.100colyear)
plot(UG1970,UG1980,data=ex02.100colyear)
plot(ex02.100colyear$UG1970,ex02.100colyear$UG1980)
View(ex02.100colyear)
x = rbinom(100, 50, 0.6)
x
phat = x/50
phat
hist(phat)
hist(phat,main="histogram of (a)")
x = rbinom(100, 50, 0.3)
phat = x/50
hist(phat,main="histogram of (b)")
x = rbinom(100, 200, 0.6)
phat = x/50
hist(phat,main="histogram of (a)")
x = rbinom(100, 200, 0.6)
phat = x/200
hist(phat,main="histogram of (c)")
x = sample(c(1:100), 10, replace=F)
x
mean(x)
mean48 = rep(0,48)
mean48
mean48 = rep(0,48)
for (i in 1:48){
x = sample(c(1:100), 10, replace=F)
mean48[i] = mean(x)
}
mean48
x = sample(c(1:100), 10, replace=F)
mean(x)
x = sample(c(1:100), 10, replace=F)
mean(x)
mean50 = c(mean48, 65.3, 64.1)
mean50
mean48
hist(mean50)
abline(v=50.5, col='red')
load("/Volumes/PERSONAL/MS/mydscr-vash/res.RData")
res[1,10000:10010]
STAT220GRADES <- read.csv("~/Desktop/STAT220GRADES.csv")
View(STAT220GRADES)
attach(STAT220GRADES)
hist(WGHTAVG)
hist(WGHTAVG,bins=30)
hist(WGHTAVG,30)
STAT220GRADES[WGHTAVG<=50,1:2]
STAT220GRADES[WGHTAVG<=60,1:2]
STAT220GRADES[50<WGHTAVG<=60,1:2]
STAT220GRADES[WGHTAVG<=60,1:2]
summary(WGHTAVG)
hist(WGHTAVG,30,breaks=100)
help(hist)
axes(side=1,at=seq(1,100))
axis(side=1,at=seq(1,100))
axis(side=1,at=seq(1,100,by=5))
hist(WGHTAVG,30,breaks=100)
axis(side=1,at=seq(1,100,by=5))
hist(WGHTAVG,30,breaks=100,xlim=c(0,100))
axis(side=1,at=seq(1,100,by=5))
hist(WGHTAVG,30,breaks=100,xlim=c(0,100))
axis(side=1,at=seq(0,100,by=5))
sum((WGHTAVG>92))
sum(WGHTAVG>92,na.rm=TRUE)
sum((WGHTAVG<=92)&(WGHTAVG>88),na.rm=TRUE)
sum(WGHTAVG>88,na.rm=TRUE)
sum(WGHTAVG>89,na.rm=TRUE)
sum((WGHTAVG<=93)&(WGHTAVG>89),na.rm=TRUE)
sum(WGHTAVG>90,na.rm=TRUE)
sum(WGHTAVG>89.5,na.rm=TRUE)
sum((WGHTAVG<=90)&(WGHTAVG>85),na.rm=TRUE)
sum((WGHTAVG<=85)&(WGHTAVG>80),na.rm=TRUE)
sum((WGHTAVG<=80)&(WGHTAVG>74),na.rm=TRUE)
sum((WGHTAVG<=74)&(WGHTAVG>68),na.rm=TRUE)
sum((WGHTAVG<=68)&(WGHTAVG>60),na.rm=TRUE)
sum(WGHTAVG<60,na.rm=TRUE)
sum(WGHTAVG<=60,na.rm=TRUE)
sum((WGHTAVG<=85)&(WGHTAVG>81),na.rm=TRUE)
sum((WGHTAVG<=93)&(WGHTAVG>89),na.rm=TRUE)
sum((WGHTAVG<=89)&(WGHTAVG>85),na.rm=TRUE)
WGHTAVG[125]
WGHTAVG[119]
WGHTAVG[124]
WGHTAVG[110]
WGHTAVG[87]
WGHTAVG[80]
WGHTAVG[73]
WGHTAVG[74]
WGHTAVG[61]
WGHTAVG[52]
WGHTAVG[48]
WGHTAVG[19]
STAT220GRADES[WGHTAVG>93,1:2]
WGHTAVG[11]
STAT220GRADES[WGHTAVG>89,1:2]
counts=matrix(1:10,ncol=2)
counts=matrix(1:20,ncol=4)
counts
group=factor(c(1,1,2,2))
library(edgeR)
y = DGEList(counts=input$counts,group=input$condition)
y = DGEList(counts,group=group)
y = calcNormFactors(y)
y = estimateCommonDisp(y)
y = estimateTagwiseDisp(y)
y = DGEList(counts,group=group)
y = calcNormFactors(y)
design=model.matrix(~group)
y = estimateGLMCommonDisp(y,design)
y = estimateGLMTrendedDisp(y,design)
y = estimateGLMTagwiseDisp(y,design)
fit = glmFit(y,design)
lrt = glmLRT(fit,coef=2)
lrt
?glmFit
glmFit()
glmFit
edgeR:::glmFit
library("ashr", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
?mixcdf
mixcdf(normalmix(c(0.5,0.5),c(0,0),c(1,2)),0)
install.packages("igraph")
library(igraph)
g = graph.lattice( c(5,6) )
?connect.neighborhood
g=graph.lattice(30,nei=2,directed=FALSE, circular=TRUE)'
)
''
g=graph.lattice(30,nei=2,directed=FALSE, circular=TRUE)
plot(g)
g=graph.lattice(9,nei=2,directed=FALSE)
plot(g)
g=graph.lattice(9,nei=3,directed=FALSE)
plot(g)
g=graph.lattice(9,nei=1,directed=FALSE)
plot(g)
g=graph.lattice(c(3,3),nei=1,directed=FALSE)
plot(g)
?graph.lattice
plot(g, vertex.color=c(rep(2,5),rep("skyblue",4))
plot(g, vertex.color=c(rep(2,5),rep("skyblue",4)))
plot(g, vertex.color=c(rep(2,5),rep("skyblue",4)))
graph=plot(g, vertex.color=c(rep(2,5),rep("skyblue",4)))
tkplot.rotate(graph,degree=90)
id=tkplot(g,layout=lay)
id=tkplot(g)
graph=plot(g, vertex.color=c(rep("yellow",5),rep("skyblue",4)))
plot(g, vertex.color=c(rep("yellow",7),rep("skyblue",2)))
plot(g, vertex.color=c(rep("yellow",9)))
plot(g, vertex.color=c(rep("skyblue",9)))
library(igraph)
g=graph.lattice(c(3,3),nei=1,directed=FALSE)
plot(g, vertex.color=c(rep("yellow",5),rep("skyblue",4)))
plot(g, vertex.color=c(rep("yellow",7),rep("skyblue",2)))
plot(g, vertex.color=c(rep("yellow",9)))
install_github("kbroman/broman")
library(devtools)
install_github("mengyin/vashr")
install.packages("manipulate")
browseVignettes("vash")
copy.packages.between.libraries(ask = T)
.libPaths()
browseVignettes("vash")
setwd("/Volumes/PERSONAL/MS/dscr-gtex-poisthin-top10000")
load("res.Rdata")
methodsub = c(1,5,8,12,13,16,17)
count = 0
curves = matrix(rep(0,length(methodsub)*10001),ncol=10001)
gridx = seq(0,1,by=1/10000)
for (seed in 1:5){
count = count+1
newres = res[res$seed==seed,]
for (i in 1:length(methodsub)){
curvex = as.numeric(newres[3*methodsub[i],10005:20004])
curvey = as.numeric(newres[3*methodsub[i],5:10004])
curves[i,]=curves[i,]+curve2grid(curvex, curvey, gridx)$gridy
}
}
curves=curves/count
source("curve2grid.R")
methodsub = c(1,5,8,12,13,16,17)
count = 0
curves = matrix(rep(0,length(methodsub)*10001),ncol=10001)
gridx = seq(0,1,by=1/10000)
for (seed in 1:5){
count = count+1
newres = res[res$seed==seed,]
for (i in 1:length(methodsub)){
curvex = as.numeric(newres[3*methodsub[i],10005:20004])
curvey = as.numeric(newres[3*methodsub[i],5:10004])
curves[i,]=curves[i,]+curve2grid(curvex, curvey, gridx)$gridy
}
}
curves=curves/count
library("ggplot2")
aaa=data.frame(cbind(gridx,t(curve)))
aaa=data.frame(cbind(gridx,t(curves)))
head(aaa)
library("reshape2")
aaa_long = melt(aaa, id="gridx")
head(aaa_long)
ggplot(data=aaa_long,
aes(x=gridx, y=value, colour=variable)) +
geom_line()
curves[,10001]
curves[,10000]
curves[,9999]
curves[,9998]
curves[,10000]=curves[,9998]
aaa = data.frame(cbind(gridx,t(curves)))
aaa_long = melt(aaa, id="gridx")
ggplot(data=aaa_long,
aes(x=gridx, y=value, colour=variable))
geom_line()
ggplot(data=aaa_long,
aes(x=gridx, y=value, colour=variable))+ geom_line()
names(aaa)
names(aaa)[2:9]=newres[3*methodsub,4]
newres[3*methodsub,4]
names(aaa)[2:8]=newres[3*methodsub,4]
aaa = data.frame(cbind(gridx,t(curves)))
names(aaa)[2:8]=newres[3*methodsub,4]
aaa_long = melt(aaa, id="gridx")
head(aaa_long)
curves_long =aaa_long
save(curves_long,file="curves_long.Rdata")
load("curves_long.RData")
method_names = as.character(unique(curves_long$variable))
checkboxGroupInput("method.subset", "Choose Methods",
choices  = method_names,
selected = method_names),
inputPanel(
# Create the checkboxes and select them all by default
# checkboxGroupInput("scen.subset", "Choose Scenarios",
# choices  = scenario_names,
# selected = scenario_names),
checkboxGroupInput("method.subset", "Choose Methods",
choices  = method_names,
selected = method_names),
# selectInput("criteria", "Choose Criteria",
# choices  = numeric_criteria,
# selected = "FDR.fsr_005")
)
getwd()
load("curves_long.RData")
method_names = as.character(unique(curves_long$variable))
load("curves_long.RData")
names(curves_long)
names(curves_long)[2]="method"
save(curves_long,file="curves_long.Rdata")
library(ggplot2)
library(dplyr)
load("curves_long.RData")
method_names = as.character(unique(curves_long$method))
res.filter = filter(curves_long,method %in% method_names)
res.filter$value = res.filter[["value"]]
ggplot(res.filter,aes(x=gridx,y=value,color=variable)) + geom_line()
ggplot(res.filter,aes(x=gridx,y=value,color=method)) + geom_line()
load("res.Rdata")
res[1:10]
res[1:10,1:10]
aaa=readRDS("./dsc-gtex-files/input/Adipose-Subcutaneous,10vs10/default_input//input.1.rds")
counts=aaa$counts
library(edgeR)
condition=aaa$condition
library(edgeR)
dgecounts = DGEList(counts=counts,group=condition)
if (args$voom.normalize == TRUE){
dgecounts = calcNormFactors(dgecounts)
}
dgecounts = calcNormFactors(dgecounts)
library(limma)
v = voom(dgecounts,design,plot=FALSE)
design = model.matrix(~condition)
v = voom(dgecounts,design,plot=FALSE)
v
fit = lmFit(input$v)
fit = lmFit(v)
fit
fit2 = eBayes(fit)
fit2
fit
sebetahat = fit$stdev.unscaled*fit$sigma
betahat = fit$coefficients[,2]
sebetahat = fit$stdev.unscaled*fit$sigma
sebetahat[1:5]
aaa$sebetahat.voom[1:5]
sebetahat = fit$stdev.unscaled[,2]*fit$sigma
sebetahat[1:5]
tscore = betahat/sebetahat
setwd("/Volumes/PERSONAL/MS/dscr-gtex-break-top10000")
aaa=readRDS("./dsc-gtex-files/input/Adipose-Subcutaneous,10vs10/default_input/input.1.rds")
setwd("/Volumes/PERSONAL/MS/dscr-gtex-top10000")
aaa=readRDS("./dsc-gtex-files//input//Adipose-Subcutaneous,2vs2//default_input//input.44.rds")
input=readRDS("./dsc-gtex-files//input//Adipose-Subcutaneous,2vs2//default_input//input.44.rds")
design = model.matrix(~input$condition)
y = DGEList(counts=input$counts+1, group=input$condition)
y = calcNormFactors(y)
y = estimateGLMCommonDisp(y,design)
y = estimateGLMTrendedDisp(y,design)
y = estimateGLMTagwiseDisp(y,design)
fit = glmFit(y,design)
lrt = glmLRT(fit,coef=2)
pvalue = lrt$table$PValue
qvalue = qvalue(pvalue)$qval
library(qvalue)
head(lrt$table)
fit
fit
lrt
lrt$table$PValue[1:5]
fit$df.residual
betahat = fit$coef[,2]
pvalue = lrt$table$PValue
df = fit$df.residual
tscore = qt(1-pvalue/2,df=df)
sebetahat = betahat/tscore
hist(sebetahat)
summary(pvalue)
summary(tscore)
sebetahat = abs(betahat/tscore)
summary(sebetahat)
hist(sebetahat)
2*(1-pt(abs(betahat/sebetahat),df=2))
pp=2*(1-pt(abs(betahat/sebetahat),df=2))
hist(pp)
hist(pvalue)
pp[1:10]
pvalue[1:10]
y = DGEList(counts=input$counts,group=input$condition)
y = calcNormFactors(y)
y = estimateCommonDisp(y)
y = estimateTagwiseDisp(y)
et = exactTest(y)
et$table
head(et$table)
head(et)
et
cds = newCountDataSet(input$counts+args$pseudocounts, input$condition )
library(DESeq)
cds = newCountDataSet(input$counts+args$pseudocounts, input$condition )
cds = newCountDataSet(input$counts+1, input$condition )
cds = estimateSizeFactors( cds )
cds = estimateDispersions( cds )
fit1 = fitNbinomGLMs( cds, count ~ condition )
fit0 = fitNbinomGLMs( cds, count ~ 1 )
aaa=nbinomGLMTest( fit1, fit0 )
fit1
head(fit1)
getwd()
setwd("../dscr-gtex-break-top10000/")
source("run_dsc_test.R")
source("run_dsc_test.R")
source("run_dsc_test.R")
